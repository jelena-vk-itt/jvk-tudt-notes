<!-- <!DOCTYPE html> -->
<html lang="en">
    <head>
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<meta charset="UTF-8" />
	<link rel="shortcut icon" type="image/x-icon" href="res/images/logo.png" />
	<link rel="stylesheet" type="text/css" href="res/styles/ooswd.css" />
	<title>OOSWD</title>
    </head>
    <body>
	<header id="tudheader">
	    <img id="leftlogo" src="../common/res/images/tudublin_logo.png" alt="TU Dublin Logo">
	    <div id="tuddepttext">
		<p>School of Computer Science</p>
	    </div>
	    <div id="titlecontainer">
		<p id="title">Classes (continued)</p>
	    </div>
	    <img id="rightlogo" src="res/images/logo.png" alt="Logo" />
	</header>

	<div id="content">
	    <nav>
		<ul class="links">
		    <li><a href="index.html">Home</a></li>
		</ul>
		<ul class="commands">
		    <li class="openall">Open all</li>
		    <li class="closeall">Close all</li>
		</ul>

	    </nav>

	    <article>
		<ol class="toc_grp newline">
		    
		    <!--------------------------------------------------------------------->            
		    <li id="ARTCLID000097">
			<p>Getters and setters</p>
			<article style="display:none">
			    <h2>Getters and setters</h2>

			    <p>In last week's lab we have defined private variables and methods for accessing them.</p>

			    <figure id="py-priv-getset">
				<figcaption>Private member variables with ordinary methods as getters and setters</figcaption><pre class="code-listing">class Product:
    
    lowStockMark = 3
    
    def __init__(self, name, stock):
        self._name = name
        self._stock = stock

    def get_name(self):
        return self._name

    def set_name(self, name):
        self._name = name

    def get_stock(self):
        return self._stock

    def set_stock(self, stock):
        self._stock = stock

    def stock_is_low(self):
        return self._stock <= Product.lowStockMark</pre>
				<table class="legend">
				    <tr><td><span class="fw">self._name<br/>self._stock</span></td><td>Private member variables <span class="fw">_name</span> and <span class="fw">_stock</span> accessed directly from within class methods</td></tr>
				    <tr><td><span class="fw">get_name<br/>set_name<br/>get_stock<br/>set_stock</span></td><td>These are 'getter' and 'setter' methods used to avoid breaking convention by directly accessing private variables</td></tr>
				</table>
				<hr/><hr/>
			    </figure>

			    <p>There is nothing wrong with this approach, but it is a little bit tedious. Python provides a mechanism for achieving the same thing more easily.</p>

			    <h3>Using the &#64;properties and setter decorators</h3>

			    <p>With the use of decorators <span class="fw">&#64;property</span> and <span class="fw">&#64;<em>property_name</em>.setter</span>, private member variables are 'wrapped' in methods for read and write access via variable (rather than function) notation.</p>
			    
			    <figure id="py-get-set-del">
				<figcaption>Properties with decorators</figcaption><pre class="code-listing">class Product:
    
    lowStockMark = 3
    
    def __init__(self, name, stock):
        self._name = name
        self._stock = stock

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, name):
        self._name = name

    @property
    def stock(self):
        return self._stock

    @stock.setter
    def stock(self, stock):
        self._stock = stock

    def stock_is_low(self):
        return self._stock <= Product.lowStockMark

# tests
p = Product("Milk", 5)
print(p.name)
p.name = "UHT milk"
print(p.name)</pre>
				<table class="legend">
				    <tr><td><span class="fw">&#64;property<br/>def name(self):</span></td><td>Method that allows <span class="fw">self._name</span> to be accessed with <em>some_object</em><span class="fw">.name</span> externally for reading</td></tr>
				    <tr><td><span class="fw">&#64;name.setter<br/>def name(self, name):</span></td><td>Method that allows <span class="fw">self._name</span> to be accessed with <em>some_object</em><span class="fw">.name</span> externally for writing</td></tr>
				</table>
				<hr/><hr/>
			    </figure>

			    <h3>Alternative way of defining properties</h3>
			    <figure id="py-property-alt">
				<figcaption>Using function property</figcaption><pre class="code-listing">class Product:
    
    lowStockMark = 3
    
    def __init__(self, name, stock):
        self.__name = name
        self.__stock = stock

    def __get_name(self):
        return self.__name

    def __set_name(self, name):
        self.__name = name

    def __get_stock(self):
        return self.__stock

    def __set_stock(self, stock):
        self.__stock = stock

    def stock_is_low(self):
        return self.__stock <= Product.lowStockMark

    name = property(__get_name, __set_name)
    stock = property(__get_stock, __set_stock)

# tests
p = Product("Milk", 5)
print(p.name)
p.name = "UHT milk"
print(p.name)</pre>
				<table class="legend">
				    <tr><td width=450><span class="fw">__get_name<br/>__set_name<br/>__get_stock<br/>__set_stock</span></td><td>Private getters and setters</td></tr>
				    <tr><td><span class="fw">name = property(__get_name, __set_name)<br/>stock = property(__get_stock, __set_stock)</span></td><td>Calls to the <span class="fw">property</span> function, which associates the names <span class="fw">name</span> and <span class="fw">stock</span> with the getters and setters, allowing the names to be used (like in the previous example) for variable-style (rather than function-style) access to the private members <span class="fw">__name</span> and <span class="fw">__stock</span></td></tr>
				</table>
				<hr/><hr/>
			    </figure>
			</article>
		    </li>

		    
	            <!--------------------------------------------------------------------->            
                    <li id="ARTCLID000146">
			<p>Static methods</p>
			<article style="display:none">
                            <h2>Static methods</h2>

			    <p>In last week's lab solution, the following method is found inside the <span class="fw">Shop</span> class:</p>

			    <figure id="py-static-method-candidates">
				<figcaption>Example of a static method candidate in Python</figcaption><pre class="code-listing">class Shop:

    # other variables and functions

    def print_footer(self):
        print(Shop.SEP_LINE)
				</pre>
			    </figure>
			    <p>As the method shown above does not access instance member variables, it does not need to be associated with an object and can be made <em>static</em>. A static method:</p>
			    <ul>
				<li>is indicated with the <span class="fw">&#64;staticmethod</span> decorator</li>
				<li>does not have the object itself (<span class="fw">self</span>) as the first parameter</li>
				<li>similarly to class member variables, can be accessed via the class</li>
				<li>can alternatively be accessed via objects</li>
			    </ul>
			    
			    <figure id="py-static-methods-declared">
				<figcaption>A static method in Python</figcaption><pre class="code-listing">class Shop:
    # other members

    @staticmethod
    def print_footer():
        print(Shop.SEP_LINE)

# tests
Shop.print_footer()
s = Shop()
s.print_footer()</pre>
				<table class="legend">
				    <tr><td><span class="fw">@staticmethod</span></td><td>Decorator that marks a method as static</td></tr>
				    <tr><td><span class="fw">def print_header(heading):</span></td><td>A static method does not include the <span class="fw">self</span> parameter</td></tr>
				    <tr><td><span class="fw">Shop.print_footer()</span></td><td>A static method being accessed via the class</td></tr>
				    <tr><td><span class="fw">s.print_footer()</span></td><td>A static method being accessed via an object</td></tr>
				</table>
				<hr/><hr/>
			    </figure>


			    
			</article>
                    </li>





		    <!--------------------------------------------------------------------->            
                    <li id="ARTCLID000103">
			<p>Class inheritance</p>
			<article style="display:none">
                            <h2>Class inheritance</h2>

			    <p>Classes can be defined as subtypes of other classes. This concept is called <strong>class inheritance</strong>.</p>

			    <p>In an inheritance relationship</p>
			    <ul>
				<li>one class is a <strong>subclass</strong> of another class, called the <strong>superclass</strong> class</li>
				<li>the superclass is always more <strong>general</strong> and the subclass more <strong>specific</strong></li>
				<li>the subclass <strong>inherits</strong> the properties (variables and methods) of the superclass</li>
				<li>thus, an object of the subclass type <strong>is</strong> an object of the superclass type</li>
				<li><strong>in addition</strong> to inherited properties, the subclass has properties that are specific to itself</li>
				<li>relationships can extend over many levels of an inheritance <strong>hierarchy</strong></li>
				<li>synonymous terms
				    <ul>
					<li>superclass, base class, parent class</li>
					<li>subclass, derived class, child class</li>
				    </ul>
				</li>
			    </ul>
			    
			    <p>In the picture below, class <span class="fw">Employee</span> is a derived from class <span class="fw">Person</span>. It inherits properties <span class="fw">name</span>, <span class="fw">surname</span>, <span class="fw">address</span> and <span class="fw">dateOfBirth</span>. An object of type <span class="fw">Employee</span> has all these properties <strong>and</strong> its own property <span class="fw">employeeNumber</span>, which does not pertain to a person in general.</p>
			    <figure>
				<figcaption>A class inheritance hierarchy</figcaption>
				<img class="w-three" src="res/images/inheritance.png">
			    </figure>

			</article>
                    </li>


		    
		    <!--------------------------------------------------------------------->            
                    <li id="ARTCLID000104">
			<p>Inheritance syntax in Python</p>
			<article style="display:none">
                            <h2>Inheritance syntax in Python</h2>

			    <figure id="py-inheritance">
				<figcaption>Class inheritance with Python</figcaption><pre class="code-listing">
class Person:
    def __init__(self, n, s):
        self.name = n
        self.surname = s

    def print(self):
        print("")
        print("name: ", self.name)
        print("surname: ", self.surname)

    def get_fullname(self):
        return self.name + " " + self.surname


class Employee(Person):
    def __init__(self, n, s, en):
        super().__init__(n, s)
        self.employeeNumber = en

    def print(self):
        super().print()
        print("employee number: ", self.employeeNumber)			    </pre>
				<table class="legend">
				    <tr><td><span class="fw">class Employee(Person)</span></td><td>a new class called <span class="fw">Employee</span> is declared as a subclass of <span class="fw">Person</span></td></tr>
				    <tr><td><span class="fw">super()</span></td><td>returns an object of the base class type</td></tr>
				    <tr><td><span class="fw">super().__init__()</span></td><td>base class constructor being called from the subclass to construct its inherited part</td></tr>
				    <tr><td><span class="fw">get_fullname()</span></td><td>inherited and callable on the subclass</td></tr>
				    <tr><td><span class="fw">print()</span></td><td>on the subclass, this is called instead of the base class <span class="fw">print</span> method</td></tr>
				</table>
				<hr/><hr/>
			    </figure>
			    <details class="ice"><summary></summary>
				<p>Copy the code from code snippet <a class="xref" href="#py-inheritance">?</a> into a script file. Then write some code to test the classes:</p>
				<ul>
				    <li>create an object of type <span class="fw">Person</span></li>
				    <li>call the function <span class="fw">print</span> on it</li>
				    <li>call the function <span class="fw">get_fullname</span> on it</li>
				    <li>repeat the previous steps with an object of type <span class="fw">Employee</span></li>
				    <li>think about the outputs until you are happy you understand how they were produced</li>
				</ul>
				<p><a href="res/files/python/classes/inheritance.py">EXAMPLE SOLUTION</a></p>
			    </details>

			    <details class="ice"><summary></summary>
				<p>Use the answer files for the team/person/address exercise (found <a href="res/files/python/classes/team.zip">here</a>) as the starting point for this exercise. Reorganise the code so that that it retains the functionality of the existing code, but with a new class <span class="fw">Employee</span> included. In the current setup, the <span class="fw">Person</span> class has a member variable for their team role, which really does not belong on <span class="fw">Person</span>, but could belong on <span class="fw">Employee</span>. The team should now consist of employees.</p>
				<p><a href="res/files/python/classes/team_reorg.zip">EXAMPLE SOLUTION</a></p>
			    </details>
			</article>
                    </li>

		    
	            <!--------------------------------------------------------------------->            
                    <li id="ARTCLID000105">
			<p>Method overriding</p>
			<article style="display:none">
                            <h2>Method overriding</h2>

			    <p>In code snippet <a class="xref" href="#py-inheritance">?</a> we have seen the subclass <span class="fw">Employee</span> define the function <span class="fw">print</span>, which has the same name and signature as the function <span class="fw">print</span> in the base class <span class="fw">Person</span>. This is called <strong>method overriding</strong> (or function overriding). As a result of overriding, the definition/execution mapping is as shown in the table.</p>
			    <table class="ordinary centre-all">
				If the base class has a function called <span class="fw">func</span>, then the following applies.
				<tr>
				    <th>object type</th><th>subclass has function <span class="fw">func</span></th><th><span class="fw">func</span> called on</th><th>executed</th><th>examples in <em>Pets class diagram</em></th>
				</tr>
				<tr>
				    <td>base</td><td>does not matter</td><td>base</td><td>base class <span class="fw">func</span></td><td><span class="fw">petObj.walkTimes()<br>petObj.feedTimes()<br>petObj.setUpAlarms()</span></td>
				</tr>
				<tr>
				    <td>subclass</td><td>&#10004;</td><td>subclass</td><td>subclass <span class="fw">func</span></td><td><span class="fw">dogObj.feedTimes()<br>dogObj.walkTimes()<br>catObj.feedTimes()</span></td>
				</tr>
				<tr>
				    <td>subclass</td><td>X</td><td>subclass</td><td>base <span class="fw">func</span></td><td><span class="fw">dogObj.setUpAlarms()<br>catObj.walkTimes()<br>cat_obj.setUpAlarms()</span></td>
				</tr>
				<tr>
				    <td>subclass</td><td>&#10004;</td><td>base</td><td>subclass <span class="fw">func</span></td><td><span class="fw">feedTimes()</span> called from <span class="fw">dogObj.setUpAlarms()</span><br><span class="fw">walkTimes()</span> called from <span class="fw">dogObj.setUpAlarms()</span><br><span class="fw">feedTimes()</span> called from <span class="fw">catObj.setUpAlarms()</span></td>
				</tr>
			    </table>
			    <figure>
				<figcaption>Pet class diagram</figcaption>
				<img class="w-three" src="res/images/func_override.png">
			    </figure>

			    <details class="ice"><summary></summary>
				<p>Implement the classes in <em>Pets class diagram</em> and test the four different scenarios that can happen when overriding/overridden functions are called. Place each class in a separate file and use a file called <em>main.py</em> for the test code.</p>
				<p><a href="res/files/python/classes/pets.zip">EXAMPLE SOLUTION</a></p>
			    </details>

			    <h3>A couple of other things to note</h3>
			    <ul>
				<li>Function overriding is at the heart of the <strong>polymorphism</strong> found in inheritance hierarchies. The word polymorphism roughly means "many shapes" and in object-oriented programming refers to how the same thing (the base class) can behave in many different ways (specific behaviour of subclasses, implemented in overriding functions).</li>
				<li>It is important for the overriding function to have the <strong>same signature</strong> (name and parameters) as the base class function. Using different overridden and overriding signatures can be made to work sometimes (or can work by chance) but this would be using polymorphism in an inintended way. Python is very permissive, which in many contexts makes it easy to work with, but this should not be abused by the programmer.</li>
			    </ul>
			</article>
                    </li>


	            <!--------------------------------------------------------------------->            
                    <li id="ARTCLID000147">
			<p>Special method names</p>
			<article style="display:none">
                            <h2>Special method names</h2>

			    <p></p>
			    <p>If added to developer-defined classes, they will be invoked in specific, well-defined circumstances.</p>
			    <p>For example, we have already seen an example of a special method name, <span class="fw">__init__</span>. This method is called just after an object of the class is created and it is expected to initialise the new object. </p>
			    <p>Other examples are:
				<ul>
				    <li><span class="fw">__repr__</span> is expected to provide a 'technical' string representation of the object, for debugging</li>
				    <li><span class="fw">__str__</span> is expected to provide a 'pretty' string representation for use by the function <span class="fw">print</span> and <span class="fw">str</span></li>
				    <li><span class="fw">__lt__</span> is expected to tell if an object is 'less than' another object (if applicable)</li>
				</ul>
			    </p>
			    <p>These methods are also referred to as <strong>dunder</strong> (double underscores) methods.</p>
			    <p>The Python documentation lists <a class="lr" href="https://docs.python.org/3/reference/datamodel.html#special-method-names">more examples</a> of these special methods.</p>
					
			</article>
			
                    </li>
		</ol>

	    </article>
	    <p id="sig">Jelena VasiÄ‡</p>
	</div>

	<script type="text/javascript" src="../common/res/scripts/main.js"></script>
	<script type="text/javascript" src="../common/res/scripts/modules/xrefs.js"></script>
	<script type="text/javascript" src="res/scripts/xrefs.js"></script>
    </body>
</html>
